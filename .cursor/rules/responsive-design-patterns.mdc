---
alwaysApply: true
---

# Responsive Design: Container Queries Over Media Queries

## Principle

Use container-based styling and `useContainerBreakpoints` for all responsive behavior. Since the SDK is embedded in various contexts and container sizes, component behavior must adapt to the component's actual container, not the viewport. This is essential for predictable behavior across different host applications.

## Guidelines

### Do This ✅

```typescript
// Good: Use useContainerBreakpoints hook with semantic components
import { useContainerBreakpoints } from '@/hooks/useContainerBreakpoints'
import { Flex } from '@/components/Common'

const PayrollReceipts = () => {
  const breakpoints = useContainerBreakpoints()
  const isSmall = breakpoints.includes('base') || breakpoints.includes('small')

  return (
    <Flex
      flexDirection={isSmall ? 'column' : 'row'}
      gap={isSmall ? 8 : 16}
    >
      {/* Component content */}
    </Flex>
  )
}

// Good: Use semantic Grid component with responsive props
import { Grid } from '@/components/Common'

const PayrollGrid = () => {
  const breakpoints = useContainerBreakpoints()
  const isMobile = breakpoints.includes('base')

  return (
    <Grid
      columns={isMobile ? 1 : 2}
      gap={isMobile ? 8 : 16}
    >
      {/* Grid items */}
    </Grid>
  )
}
```

### Avoid This ❌

```typescript
// Bad: CSS media queries in component styles
.payroll-receipts {
  display: flex;
  flex-direction: row;
  gap: 16px;
}

@media (max-width: 768px) {
  .payroll-receipts {
    /* This doesn't consider container context */
    flex-direction: column;
    gap: 8px;
  }
}

// Bad: CSS container queries - use components instead
.payroll-container {
  container-type: inline-size;
}

@container (max-width: 768px) {
  .payroll-receipts {
    flex-direction: column;
    gap: 8px;
  }
}

// Bad: Viewport-based responsive logic
const PayrollReceipts = () => {
  const [isMobile, setIsMobile] = useState(false)

  useEffect(() => {
    const handleResize = () => {
      setIsMobile(window.innerWidth < 768)
    }

    window.addEventListener('resize', handleResize)
    return () => window.removeEventListener('resize', handleResize)
  }, [])

  // Component relies on viewport, not container
}

// Bad: Class-based responsive styling
const PayrollReceipts = () => {
  const breakpoints = useContainerBreakpoints()

  return (
    <div className={clsx('payroll-receipts', {
      'payroll-receipts--mobile': breakpoints.includes('base'),
      'payroll-receipts--desktop': !breakpoints.includes('base'),
    })}>
      {/* Component content */}
    </div>
  )
}
```

## Implementation Pattern

### useContainerBreakpoints Hook

```typescript
// Import the hook
import { useContainerBreakpoints } from '@/hooks/useContainerBreakpoints'

// Use it to get active breakpoints
const breakpoints = useContainerBreakpoints()

// Check for specific breakpoints
const isSmall = breakpoints.includes('base') || breakpoints.includes('small')
const isMedium = breakpoints.includes('medium')
const isLarge = breakpoints.includes('large')

// Use breakpoints to control component props
<Flex flexDirection={isSmall ? 'column' : 'row'} gap={isSmall ? 8 : 16} />
<Grid columns={isMobile ? 1 : 2} gap={isSmall ? 8 : 16} />
```

## Available Breakpoints

The `useContainerBreakpoints` hook returns an array of active breakpoint names:

- `base` - Small containers
- `small` - Small containers
- `medium` - Medium containers
- `large` - Large containers

## Performance Considerations

### Prefer Flex and Grid Components First

- **Grid and Flex components** use native CSS container queries under the hood
- Native CSS queries are more performant than JavaScript-based breakpoint detection
- Use these semantic components as your primary choice for responsive layouts

```typescript
// Preferred: Uses native CSS container queries
import { Flex, Grid } from '@/components/Common'

const PayrollLayout = () => (
  <Flex flexDirection={{ base: 'column', medium: 'row' }} gap={16}>
    {/* Responsive without JavaScript */}
  </Flex>
)
```

### Use useContainerBreakpoints for Exceptional Cases

- `useContainerBreakpoints` is JavaScript-based and more performance intensive
- Only use this hook when you need component-level conditional logic that can't be expressed through component props
- Examples: Conditional rendering, complex state changes, or non-layout responsive behavior

```typescript
// Use only when necessary: Component-level logic based on container size
import { useContainerBreakpoints } from '@/hooks/useContainerBreakpoints'

const ComplexComponent = () => {
  const breakpoints = useContainerBreakpoints()
  const isSmall = breakpoints.includes('base')

  // Only render expensive component on larger screens
  if (isSmall) {
    return <CompactView />
  }

  return <FullView />
}
```

## Benefits

1. **Essential for embedded SDK**: Components adapt to any container size in host applications
2. **Container independence**: Behavior based on component's container, not viewport
3. **Predictable scaling**: Works in sidebars, modals, full-page, or narrow containers
4. **Better testing**: Predictable responsive behavior without viewport mocking
5. **Future-proof**: Scales with design system evolution and SDK usage patterns

name: Auto Label PRs
on:
  pull_request:
    types: [opened, synchronize, reopened]

jobs:
  auto-label:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get commit messages
        id: commit-messages
        run: |
          # Ensure we have the base branch
          git fetch origin ${{ github.base_ref }}:${{ github.base_ref }} 2>/dev/null || true
          
          # Get all commit messages from the PR using the right reference
          # In PRs, HEAD contains the PR branch and we compare against the base branch
          if git rev-parse --verify ${{ github.base_ref }} >/dev/null 2>&1; then
            BASE_REF="${{ github.base_ref }}"
          elif git rev-parse --verify origin/${{ github.base_ref }} >/dev/null 2>&1; then
            BASE_REF="origin/${{ github.base_ref }}"
          else
            echo "Warning: Could not find base branch, using HEAD~1"
            BASE_REF="HEAD~1"
          fi
          
          MESSAGES=$(git log --format="%s" ${BASE_REF}..HEAD)
          echo "messages<<EOF" >> $GITHUB_OUTPUT
          echo "$MESSAGES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Get changed files
        id: changed-files
        run: |
          # Determine the correct base reference (same logic as commit messages)
          if git rev-parse --verify ${{ github.base_ref }} >/dev/null 2>&1; then
            BASE_REF="${{ github.base_ref }}"
          elif git rev-parse --verify origin/${{ github.base_ref }} >/dev/null 2>&1; then
            BASE_REF="origin/${{ github.base_ref }}"
          else
            echo "Warning: Could not find base branch, using HEAD~1"
            BASE_REF="HEAD~1"
          fi
          
          # Get all changed files
          ALL_CHANGED_FILES=$(git diff --name-only ${BASE_REF}...HEAD)
          echo "all-changed-files<<EOF" >> $GITHUB_OUTPUT
          echo "$ALL_CHANGED_FILES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          # Function to check if files match pattern and set output
          check_files() {
            local category=$1
            local pattern=$2
            if echo "$ALL_CHANGED_FILES" | grep -qE "$pattern"; then
              echo "${category}_any_changed=true" >> $GITHUB_OUTPUT
            else
              echo "${category}_any_changed=false" >> $GITHUB_OUTPUT
            fi
          }
          
          # Check each category
          check_files "payroll"    "^(src/components/Payroll/|src/.*/payroll/)"
          check_files "company"    "^(src/components/Company/|src/.*/company/)"
          check_files "employee"   "^(src/components/Employee/|src/.*/employee/)"
          check_files "contractor" "^(src/components/Contractor/|src/.*/contractor/)"
          check_files "common_ui"  "^(src/components/Common/|src/components/Base/)"
          check_files "styles"     "(^|/)src/styles/|.*\.(scss|css)$"
          check_files "docs"       "^(docs/|.*\.md$)"
          check_files "build"      "^(build/|package\.json|package-lock\.json|tsconfig\.json|vite\.config\.ts|\.github/|eslint\.config\.mjs)"

      - name: Determine labels
        id: labels
        run: |
          LABELS=()

          # Domain labels based on changed files
          if [[ "${{ steps.changed-files.outputs.payroll_any_changed }}" == "true" ]]; then
            LABELS+=("domain:payroll")
          fi

          if [[ "${{ steps.changed-files.outputs.company_any_changed }}" == "true" ]]; then
            LABELS+=("domain:company")
          fi

          if [[ "${{ steps.changed-files.outputs.employee_any_changed }}" == "true" ]]; then
            LABELS+=("domain:employee")
          fi

          if [[ "${{ steps.changed-files.outputs.contractor_any_changed }}" == "true" ]]; then
            LABELS+=("domain:contractor")
          fi

          # Area labels
          if [[ "${{ steps.changed-files.outputs.common_ui_any_changed }}" == "true" ]]; then
            LABELS+=("common-ui")
          fi

          if [[ "${{ steps.changed-files.outputs.styles_any_changed }}" == "true" ]]; then
            LABELS+=("styles")
          fi

          if [[ "${{ steps.changed-files.outputs.docs_any_changed }}" == "true" ]]; then
            LABELS+=("docs")
          fi

          if [[ "${{ steps.changed-files.outputs.build_any_changed }}" == "true" ]]; then
            LABELS+=("build")
          fi

          # Conventional commit detection from commit messages
          COMMIT_MESSAGES="${{ steps.commit-messages.outputs.messages }}"

          # feat: new features
          if echo "$COMMIT_MESSAGES" | grep -qE '(^|\n)feat(\(.+\))?:'; then
            LABELS+=("feat")
          fi

          # fix: bug fixes
          if echo "$COMMIT_MESSAGES" | grep -qE '(^|\n)fix(\(.+\))?:'; then
            LABELS+=("fix")
          fi

          # docs: documentation
          if echo "$COMMIT_MESSAGES" | grep -qE '(^|\n)docs(\(.+\))?:'; then
            LABELS+=("docs")
          fi

          # chore: maintenance
          if echo "$COMMIT_MESSAGES" | grep -qE '(^|\n)chore(\(.+\))?:'; then
            LABELS+=("chore")
          fi

          # style: code style changes
          if echo "$COMMIT_MESSAGES" | grep -qE '(^|\n)style(\(.+\))?:'; then
            LABELS+=("style")
          fi

          # refactor: code refactoring
          if echo "$COMMIT_MESSAGES" | grep -qE '(^|\n)refactor(\(.+\))?:'; then
            LABELS+=("refactor")
          fi

          # perf: performance improvements
          if echo "$COMMIT_MESSAGES" | grep -qE '(^|\n)perf(\(.+\))?:'; then
            LABELS+=("perf")
          fi

          # test: testing
          if echo "$COMMIT_MESSAGES" | grep -qE '(^|\n)test(\(.+\))?:'; then
            LABELS+=("test")
          fi

          # build: build system changes (commit message)
          if echo "$COMMIT_MESSAGES" | grep -qE '(^|\n)build(\(.+\))?:'; then
            LABELS+=("build")
          fi

          # ci: CI/CD changes
          if echo "$COMMIT_MESSAGES" | grep -qE '(^|\n)ci(\(.+\))?:'; then
            LABELS+=("ci")
          fi

          # Remove duplicates and convert array to comma-separated string
          # Sort and remove duplicates using associative array
          declare -A unique_labels
          for label in "${LABELS[@]}"; do
            unique_labels["$label"]=1
          done

          # Convert back to array
          UNIQUE_LABELS=($(printf '%s\n' "${!unique_labels[@]}" | sort))

          IFS=','
          LABEL_STRING="${UNIQUE_LABELS[*]}"
          echo "labels=$LABEL_STRING" >> $GITHUB_OUTPUT

      - name: Output determined labels
        if: steps.labels.outputs.labels != ''
        run: |
          echo "üè∑Ô∏è  Labels determined for this PR:"
          echo "${{ steps.labels.outputs.labels }}" | tr ',' '\n' | sed 's/^/  - /'
          echo ""
          echo "‚ÑπÔ∏è  These labels would be applied automatically if IP restrictions allow API access."

      - name: Apply labels
        if: steps.labels.outputs.labels != ''
        continue-on-error: true
        uses: actions/github-script@v7
        with:
          script: |
            const labels = '${{ steps.labels.outputs.labels }}'.split(',').filter(label => label.trim() !== '');

            if (labels.length > 0) {
              try {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  labels: labels
                });
                
                console.log(`‚úÖ Successfully applied labels: ${labels.join(', ')}`);
              } catch (error) {
                console.log(`‚ùå Failed to apply labels due to: ${error.message}`);
                console.log(`üìù Labels that should be applied: ${labels.join(', ')}`);
                
                if (error.message.includes('IP allow list')) {
                  console.log(`üîí This appears to be due to IP allowlist restrictions in the organization.`);
                  console.log(`üí° The labels were determined correctly but cannot be applied automatically.`);
                  console.log(`üîß Consider adding the GitHub Actions runner IPs to the organization's allowlist.`);
                }
                
                // Re-throw to mark the step as failed (but continue-on-error will let workflow continue)
                throw error;
              }
            }
